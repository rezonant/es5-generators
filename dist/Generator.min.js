/*! es5-generators 2015-07-26 */
function Generator(cb){var self=this;self._registeredEmits=[],self._registeredCatches=[],self._registeredDones=[];var callback=function(fns,args){for(var i=0,max=fns.length;max>i;++i)fns[i].apply(null,args)},done=function(){setTimeout(function(){callback(self._registeredDones,[])},1)},reject=function(error){setTimeout(function(){callback(self._registeredCatches,[error])},1)},emit=function(item,cancel){setTimeout(function(){callback(self._registeredEmits,[item,cancel])},1)};if("GeneratorFunction"==cb.constructor.name&&(cb=cb()),"GeneratorFunctionPrototype"==cb.constructor.name){for(var item,cancelled=!1;!cancelled&&!(item=cb.next()).done;)emit(item.value,function(){cancelled=!0});return void done()}if("Array"==cb.constructor.name){for(var items=cb,cancelled=!1,i=0,max=items.length;max>i;++i)emit(items[i],function(){cancelled=!0});return void done()}return"Promise"==cb.constructor.name?void cb.then(function(result){emit(result,function(){}),done()}):void cb(done,reject,emit)}"undefined"!=typeof window&&(window.Generator=Generator),"undefined"!=typeof module&&(module.exports=Generator),Generator.InvalidResolution={error:"streamablePromise-invalid-resolution",message:"You cannot resolve() a Generator with a value. The Promise value of a generator is always an array of yielded items"},Generator.InvalidSubpromiseResolution={error:"streamablePromise-invalid-subresolution",message:"While attempting to combine the results of multiple promises, one of the promises returned an item which was not an array."},Generator.resolve=function(value){return new Generator(function(done,reject,emit){emit(value),done()})},Generator.splitPromise=function(promise){return new Generator(function(done,reject,emit){promise.then(function(result){for(var i=0,max=result.length;max>i;++i)emit(result[i]);done()})})},Generator.union=function(generators){return new Generator(function(done,reject,emit){for(var promises=[],i=0,max=generators.length;max>i;++i){var generator=generators[i];generator.emit?(generator.emit(function(item){emit(item)}),promises.push(generator.done())):(Console.log("WARNING: Passing promises directly to Generator.union() is deprecated. Please wrap the promise in a Generator first."),promises.push(generator.then(function(items){if("object"!=typeof items||void 0===items.length)throw Generator.InvalidSubpromiseResolution;for(var j=0,jMax=items.length;jMax>j;++j)emit(items[j])})))}Promise.all(promises).then(function(){done()})})},Generator.exclude=function(setA,setB,comparator){return void 0===comparator&&(comparator=function(a,b){return a===b}),new Generator(function(resolve,reject,emit){var itemsA=[],itemsB=[];Promise.all([setA.then(function(items){itemsA=items}),setB.then(function(items){itemsB=items})]).then(function(){for(var i=0,max=itemsA.length;max>i;++i){for(var itemA=itemsA[i],skip=!1,j=0,jMax=itemsB.length;jMax>j;++j){var itemB=itemsB[j];if(comparator(itemA,itemB)){skip=!0;break}}skip||emit(itemA)}resolve()})})},Generator.intersectByHash=function(generators,hasher){return new Generator(function(resolve,reject,emit){for(var map={},handlers=[],i=0,max=generators.length;max>i;++i){var generator=generators[i],handleEmit=function(item){var id=hasher(item),count=0;map[id]&&(count=map[id]),count+=1,map[id]=count,count==generators.length&&emit(item)};generator.emit?handlers.push(new Promise(function(resolve,reject){generator.emit(handleEmit).done(function(){resolve()})})):(console.log("WARNING: Passing promises to Generator.intersectByHash() is deprecated. Please wrap it in a Generator first."),handlers.push(generator.then(function(items){for(var j=0,jMax=items.length;jMax>j;++j)handleEmit(items[j])})))}Promise.all(handlers).then(function(){resolve()})})},Generator.intersectByComparison=function(generators,comparator){return new Generator(function(resolve,reject,emit){for(var handlers=[],distinctItems=[],i=0,max=generators.length;max>i;++i){var generator=generators[i],handleEmit=function(item){for(var found=!1,j=0,jMax=distinctItems.length;jMax>j;++j){var distinctItem=distinctItems[j];if(comparator(distinctItem.item,item)){distinctItem.count+=1,distinctItem.emitted||distinctItem.count!=generators.length||(distinctItem.emitted=!0,emit(distinctItem.item)),found=!0;break}}if(!found){var distinctItem={item:item,count:1,emitted:!1};distinctItem.count==generators.length&&(emit(distinctItem.item),distinctItem.emitted=!0),distinctItems.push(distinctItem)}};generator.emit?handlers.push(new Promise(function(resolve,reject){generator.emit(handleEmit).then(function(){resolve()})})):handlers.push(generator.then(function(items){for(var j=0,jMax=items.length;jMax>j;++j)handleEmit(items[j])}))}Promise.all(handlers).then(function(){resolve()})})},Generator.prototype.emit=function(cb){if(!cb){var self=this;return new Promise(function(resolve,reject){var handler;self.emit(handler=function(item){resolve(item)})})}return this._registeredEmits.push(cb),this},Generator.prototype.deregister=function(event,cb){var map={emit:this._registeredEmits,"catch":this._registeredCatches,done:this._registeredDones};map[event].indexOf(cb)>=0&&map[event].splice(map[event].indexOf(cb),1)},Generator.prototype["catch"]=function(cb){if(!cb){var self=this;return new Promise(function(resolve){self["catch"](function(err){resolve(err)})})}return this._registeredCatches.push(cb),this},Generator.prototype.done=function(cb){if(!cb){var self=this;return new Promise(function(resolve,reject){self.done(function(){resolve()})["catch"](function(err){reject(err)})})}return this._registeredDones.push(cb),this},Generator.prototype.then=function(cb){var self=this;return new Promise(function(resolve,reject){var items=[];self.emit(function(item){items.push(item)}).done(function(){try{var result=cb(items);resolve(result)}catch(e){reject(e)}})})};